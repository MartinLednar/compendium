import {
  require_lib,
  require_url
} from "./chunk-PX2J2ZYM.js";
import {
  ApolloLink,
  Observable,
  __rest,
  core_exports,
  graphql_exports,
  http_exports,
  init_core,
  init_core2,
  init_graphql,
  init_http,
  init_tslib_es6,
  init_utilities,
  utilities_exports
} from "./chunk-LMTF2XFW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-TFWDKVI3.js";

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// ../../node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "../../node_modules/debug/src/debug.js"(exports, module) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module) {
    exports = module.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/utils/logger.js
var require_logger = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/utils/logger.js"(exports) {
    "use strict";
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = require_browser();
    var debugLogger = debug_1.default("aws-appsync");
    var extend = function(category) {
      if (category === void 0) {
        category = "";
      }
      var newCategory = category ? __spreadArrays(this.namespace.split(":"), [category]).join(":") : this.namespace;
      var result = debug_1.default(newCategory);
      result.extend = extend.bind(result);
      return result;
    };
    debugLogger.extend = extend.bind(debugLogger);
    exports.default = debugLogger;
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/utils/index.js
var require_utils = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger_1 = require_logger();
    exports.rootLogger = logger_1.default;
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/vendor/paho-mqtt.js
var require_paho_mqtt = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/vendor/paho-mqtt.js"(exports, module) {
    (function ExportLibrary(root, factory) {
      if (typeof exports === "object" && typeof module === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        exports = factory();
      } else {
        root.Paho = factory();
      }
    })(exports, function LibraryFactory() {
      var PahoMQTT = function(global2) {
        var version2 = "@VERSION@-@BUILDLEVEL@";
        var localStorage = global2.localStorage || function() {
          var data = {};
          return {
            setItem: function(key, item) {
              data[key] = item;
            },
            getItem: function(key) {
              return data[key];
            },
            removeItem: function(key) {
              delete data[key];
            }
          };
        }();
        var MESSAGE_TYPE = {
          CONNECT: 1,
          CONNACK: 2,
          PUBLISH: 3,
          PUBACK: 4,
          PUBREC: 5,
          PUBREL: 6,
          PUBCOMP: 7,
          SUBSCRIBE: 8,
          SUBACK: 9,
          UNSUBSCRIBE: 10,
          UNSUBACK: 11,
          PINGREQ: 12,
          PINGRESP: 13,
          DISCONNECT: 14
        };
        var validate2 = function(obj, keys) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              if (keys.hasOwnProperty(key)) {
                if (typeof obj[key] !== keys[key])
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));
              } else {
                var errorStr = "Unknown property, " + key + ". Valid properties are:";
                for (var validKey in keys)
                  if (keys.hasOwnProperty(validKey))
                    errorStr = errorStr + " " + validKey;
                throw new Error(errorStr);
              }
            }
          }
        };
        var scope = function(f2, scope2) {
          return function() {
            return f2.apply(scope2, arguments);
          };
        };
        var ERROR = {
          OK: { code: 0, text: "AMQJSC0000I OK." },
          CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." },
          SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." },
          UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." },
          PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." },
          INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" },
          CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." },
          SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." },
          SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." },
          MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." },
          UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." },
          INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." },
          INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." },
          INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." },
          UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." },
          INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key={0} value={1}." },
          INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." },
          MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." },
          BUFFER_FULL: { code: 18, text: "AMQJS0018E Message buffer is full, maximum buffer size: {0}." }
        };
        var CONNACK_RC = {
          0: "Connection Accepted",
          1: "Connection Refused: unacceptable protocol version",
          2: "Connection Refused: identifier rejected",
          3: "Connection Refused: server unavailable",
          4: "Connection Refused: bad user name or password",
          5: "Connection Refused: not authorized"
        };
        var format = function(error, substitutions) {
          var text = error.text;
          if (substitutions) {
            var field, start;
            for (var i = 0; i < substitutions.length; i++) {
              field = "{" + i + "}";
              start = text.indexOf(field);
              if (start > 0) {
                var part1 = text.substring(0, start);
                var part2 = text.substring(start + field.length);
                text = part1 + substitutions[i] + part2;
              }
            }
          }
          return text;
        };
        var MqttProtoIdentifierv3 = [0, 6, 77, 81, 73, 115, 100, 112, 3];
        var MqttProtoIdentifierv4 = [0, 4, 77, 81, 84, 84, 4];
        var WireMessage = function(type, options) {
          this.type = type;
          for (var name in options) {
            if (options.hasOwnProperty(name)) {
              this[name] = options[name];
            }
          }
        };
        WireMessage.prototype.encode = function() {
          var first = (this.type & 15) << 4;
          var remLength = 0;
          var topicStrLength = [];
          var destinationNameLength = 0;
          var willMessagePayloadBytes;
          if (this.messageIdentifier !== void 0)
            remLength += 2;
          switch (this.type) {
            case MESSAGE_TYPE.CONNECT:
              switch (this.mqttVersion) {
                case 3:
                  remLength += MqttProtoIdentifierv3.length + 3;
                  break;
                case 4:
                  remLength += MqttProtoIdentifierv4.length + 3;
                  break;
              }
              remLength += UTF8Length(this.clientId) + 2;
              if (this.willMessage !== void 0) {
                remLength += UTF8Length(this.willMessage.destinationName) + 2;
                willMessagePayloadBytes = this.willMessage.payloadBytes;
                if (!(willMessagePayloadBytes instanceof Uint8Array))
                  willMessagePayloadBytes = new Uint8Array(payloadBytes);
                remLength += willMessagePayloadBytes.byteLength + 2;
              }
              if (this.userName !== void 0)
                remLength += UTF8Length(this.userName) + 2;
              if (this.password !== void 0)
                remLength += UTF8Length(this.password) + 2;
              break;
            case MESSAGE_TYPE.SUBSCRIBE:
              first |= 2;
              for (var i = 0; i < this.topics.length; i++) {
                topicStrLength[i] = UTF8Length(this.topics[i]);
                remLength += topicStrLength[i] + 2;
              }
              remLength += this.requestedQos.length;
              break;
            case MESSAGE_TYPE.UNSUBSCRIBE:
              first |= 2;
              for (var i = 0; i < this.topics.length; i++) {
                topicStrLength[i] = UTF8Length(this.topics[i]);
                remLength += topicStrLength[i] + 2;
              }
              break;
            case MESSAGE_TYPE.PUBREL:
              first |= 2;
              break;
            case MESSAGE_TYPE.PUBLISH:
              if (this.payloadMessage.duplicate)
                first |= 8;
              first = first |= this.payloadMessage.qos << 1;
              if (this.payloadMessage.retained)
                first |= 1;
              destinationNameLength = UTF8Length(this.payloadMessage.destinationName);
              remLength += destinationNameLength + 2;
              var payloadBytes = this.payloadMessage.payloadBytes;
              remLength += payloadBytes.byteLength;
              if (payloadBytes instanceof ArrayBuffer)
                payloadBytes = new Uint8Array(payloadBytes);
              else if (!(payloadBytes instanceof Uint8Array))
                payloadBytes = new Uint8Array(payloadBytes.buffer);
              break;
            case MESSAGE_TYPE.DISCONNECT:
              break;
            default:
              break;
          }
          var mbi = encodeMBI(remLength);
          var pos = mbi.length + 1;
          var buffer = new ArrayBuffer(remLength + pos);
          var byteStream = new Uint8Array(buffer);
          byteStream[0] = first;
          byteStream.set(mbi, 1);
          if (this.type == MESSAGE_TYPE.PUBLISH)
            pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);
          else if (this.type == MESSAGE_TYPE.CONNECT) {
            switch (this.mqttVersion) {
              case 3:
                byteStream.set(MqttProtoIdentifierv3, pos);
                pos += MqttProtoIdentifierv3.length;
                break;
              case 4:
                byteStream.set(MqttProtoIdentifierv4, pos);
                pos += MqttProtoIdentifierv4.length;
                break;
            }
            var connectFlags = 0;
            if (this.cleanSession)
              connectFlags = 2;
            if (this.willMessage !== void 0) {
              connectFlags |= 4;
              connectFlags |= this.willMessage.qos << 3;
              if (this.willMessage.retained) {
                connectFlags |= 32;
              }
            }
            if (this.userName !== void 0)
              connectFlags |= 128;
            if (this.password !== void 0)
              connectFlags |= 64;
            byteStream[pos++] = connectFlags;
            pos = writeUint16(this.keepAliveInterval, byteStream, pos);
          }
          if (this.messageIdentifier !== void 0)
            pos = writeUint16(this.messageIdentifier, byteStream, pos);
          switch (this.type) {
            case MESSAGE_TYPE.CONNECT:
              pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);
              if (this.willMessage !== void 0) {
                pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);
                pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);
                byteStream.set(willMessagePayloadBytes, pos);
                pos += willMessagePayloadBytes.byteLength;
              }
              if (this.userName !== void 0)
                pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);
              if (this.password !== void 0)
                pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);
              break;
            case MESSAGE_TYPE.PUBLISH:
              byteStream.set(payloadBytes, pos);
              break;
            case MESSAGE_TYPE.SUBSCRIBE:
              for (var i = 0; i < this.topics.length; i++) {
                pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
                byteStream[pos++] = this.requestedQos[i];
              }
              break;
            case MESSAGE_TYPE.UNSUBSCRIBE:
              for (var i = 0; i < this.topics.length; i++)
                pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
              break;
            default:
          }
          return buffer;
        };
        function decodeMessage(input, pos) {
          var startingPos = pos;
          var first = input[pos];
          var type = first >> 4;
          var messageInfo = first &= 15;
          pos += 1;
          var digit;
          var remLength = 0;
          var multiplier = 1;
          do {
            if (pos == input.length) {
              return [null, startingPos];
            }
            digit = input[pos++];
            remLength += (digit & 127) * multiplier;
            multiplier *= 128;
          } while ((digit & 128) !== 0);
          var endPos = pos + remLength;
          if (endPos > input.length) {
            return [null, startingPos];
          }
          var wireMessage = new WireMessage(type);
          switch (type) {
            case MESSAGE_TYPE.CONNACK:
              var connectAcknowledgeFlags = input[pos++];
              if (connectAcknowledgeFlags & 1)
                wireMessage.sessionPresent = true;
              wireMessage.returnCode = input[pos++];
              break;
            case MESSAGE_TYPE.PUBLISH:
              var qos = messageInfo >> 1 & 3;
              var len = readUint16(input, pos);
              pos += 2;
              var topicName = parseUTF8(input, pos, len);
              pos += len;
              if (qos > 0) {
                wireMessage.messageIdentifier = readUint16(input, pos);
                pos += 2;
              }
              var message = new PahoMQTT.Message(input.subarray(pos, endPos));
              if ((messageInfo & 1) == 1)
                message.retained = true;
              if ((messageInfo & 8) == 8)
                message.duplicate = true;
              message.qos = qos;
              message.destinationName = topicName;
              wireMessage.payloadMessage = message;
              break;
            case MESSAGE_TYPE.PUBACK:
            case MESSAGE_TYPE.PUBREC:
            case MESSAGE_TYPE.PUBREL:
            case MESSAGE_TYPE.PUBCOMP:
            case MESSAGE_TYPE.UNSUBACK:
              wireMessage.messageIdentifier = readUint16(input, pos);
              break;
            case MESSAGE_TYPE.SUBACK:
              wireMessage.messageIdentifier = readUint16(input, pos);
              pos += 2;
              wireMessage.returnCode = input.subarray(pos, endPos);
              break;
            default:
              break;
          }
          return [wireMessage, endPos];
        }
        function writeUint16(input, buffer, offset) {
          buffer[offset++] = input >> 8;
          buffer[offset++] = input % 256;
          return offset;
        }
        function writeString(input, utf8Length, buffer, offset) {
          offset = writeUint16(utf8Length, buffer, offset);
          stringToUTF8(input, buffer, offset);
          return offset + utf8Length;
        }
        function readUint16(buffer, offset) {
          return 256 * buffer[offset] + buffer[offset + 1];
        }
        function encodeMBI(number) {
          var output = new Array(1);
          var numBytes = 0;
          do {
            var digit = number % 128;
            number = number >> 7;
            if (number > 0) {
              digit |= 128;
            }
            output[numBytes++] = digit;
          } while (number > 0 && numBytes < 4);
          return output;
        }
        function UTF8Length(input) {
          var output = 0;
          for (var i = 0; i < input.length; i++) {
            var charCode = input.charCodeAt(i);
            if (charCode > 2047) {
              if (55296 <= charCode && charCode <= 56319) {
                i++;
                output++;
              }
              output += 3;
            } else if (charCode > 127)
              output += 2;
            else
              output++;
          }
          return output;
        }
        function stringToUTF8(input, output, start) {
          var pos = start;
          for (var i = 0; i < input.length; i++) {
            var charCode = input.charCodeAt(i);
            if (55296 <= charCode && charCode <= 56319) {
              var lowCharCode = input.charCodeAt(++i);
              if (isNaN(lowCharCode)) {
                throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));
              }
              charCode = (charCode - 55296 << 10) + (lowCharCode - 56320) + 65536;
            }
            if (charCode <= 127) {
              output[pos++] = charCode;
            } else if (charCode <= 2047) {
              output[pos++] = charCode >> 6 & 31 | 192;
              output[pos++] = charCode & 63 | 128;
            } else if (charCode <= 65535) {
              output[pos++] = charCode >> 12 & 15 | 224;
              output[pos++] = charCode >> 6 & 63 | 128;
              output[pos++] = charCode & 63 | 128;
            } else {
              output[pos++] = charCode >> 18 & 7 | 240;
              output[pos++] = charCode >> 12 & 63 | 128;
              output[pos++] = charCode >> 6 & 63 | 128;
              output[pos++] = charCode & 63 | 128;
            }
          }
          return output;
        }
        function parseUTF8(input, offset, length) {
          var output = "";
          var utf16;
          var pos = offset;
          while (pos < offset + length) {
            var byte1 = input[pos++];
            if (byte1 < 128)
              utf16 = byte1;
            else {
              var byte2 = input[pos++] - 128;
              if (byte2 < 0)
                throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), ""]));
              if (byte1 < 224)
                utf16 = 64 * (byte1 - 192) + byte2;
              else {
                var byte3 = input[pos++] - 128;
                if (byte3 < 0)
                  throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));
                if (byte1 < 240)
                  utf16 = 4096 * (byte1 - 224) + 64 * byte2 + byte3;
                else {
                  var byte4 = input[pos++] - 128;
                  if (byte4 < 0)
                    throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
                  if (byte1 < 248)
                    utf16 = 262144 * (byte1 - 240) + 4096 * byte2 + 64 * byte3 + byte4;
                  else
                    throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
                }
              }
            }
            if (utf16 > 65535) {
              utf16 -= 65536;
              output += String.fromCharCode(55296 + (utf16 >> 10));
              utf16 = 56320 + (utf16 & 1023);
            }
            output += String.fromCharCode(utf16);
          }
          return output;
        }
        var Pinger = function(client, keepAliveInterval) {
          this._client = client;
          this._keepAliveInterval = keepAliveInterval * 1e3;
          this.isReset = false;
          var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();
          var doTimeout = function(pinger) {
            return function() {
              return doPing.apply(pinger);
            };
          };
          var doPing = function() {
            if (!this.isReset) {
              this._client._trace("Pinger.doPing", "Timed out");
              this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));
            } else {
              this.isReset = false;
              this._client._trace("Pinger.doPing", "send PINGREQ");
              this._client.socket.send(pingReq);
              this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);
            }
          };
          this.reset = function() {
            this.isReset = true;
            clearTimeout(this.timeout);
            if (this._keepAliveInterval > 0)
              this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);
          };
          this.cancel = function() {
            clearTimeout(this.timeout);
          };
        };
        var Timeout = function(client, timeoutSeconds, action, args) {
          if (!timeoutSeconds)
            timeoutSeconds = 30;
          var doTimeout = function(action2, client2, args2) {
            return function() {
              return action2.apply(client2, args2);
            };
          };
          this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1e3);
          this.cancel = function() {
            clearTimeout(this.timeout);
          };
        };
        var ClientImpl = function(uri, host, port, path, clientId) {
          if (!("WebSocket" in global2 && global2.WebSocket !== null)) {
            throw new Error(format(ERROR.UNSUPPORTED, ["WebSocket"]));
          }
          if (!("ArrayBuffer" in global2 && global2.ArrayBuffer !== null)) {
            throw new Error(format(ERROR.UNSUPPORTED, ["ArrayBuffer"]));
          }
          this._trace("Paho.Client", uri, host, port, path, clientId);
          this.host = host;
          this.port = port;
          this.path = path;
          this.uri = uri;
          this.clientId = clientId;
          this._wsuri = null;
          this._localKey = host + ":" + port + (path != "/mqtt" ? ":" + path : "") + ":" + clientId + ":";
          this._msg_queue = [];
          this._buffered_msg_queue = [];
          this._sentMessages = {};
          this._receivedMessages = {};
          this._notify_msg_sent = {};
          this._message_identifier = 1;
          this._sequence = 0;
          for (var key in localStorage)
            if (key.indexOf("Sent:" + this._localKey) === 0 || key.indexOf("Received:" + this._localKey) === 0)
              this.restore(key);
        };
        ClientImpl.prototype.host = null;
        ClientImpl.prototype.port = null;
        ClientImpl.prototype.path = null;
        ClientImpl.prototype.uri = null;
        ClientImpl.prototype.clientId = null;
        ClientImpl.prototype.socket = null;
        ClientImpl.prototype.connected = false;
        ClientImpl.prototype.maxMessageIdentifier = 65536;
        ClientImpl.prototype.connectOptions = null;
        ClientImpl.prototype.hostIndex = null;
        ClientImpl.prototype.onConnected = null;
        ClientImpl.prototype.onConnectionLost = null;
        ClientImpl.prototype.onMessageDelivered = null;
        ClientImpl.prototype.onMessageArrived = null;
        ClientImpl.prototype.traceFunction = null;
        ClientImpl.prototype._msg_queue = null;
        ClientImpl.prototype._buffered_msg_queue = null;
        ClientImpl.prototype._connectTimeout = null;
        ClientImpl.prototype.sendPinger = null;
        ClientImpl.prototype.receivePinger = null;
        ClientImpl.prototype._reconnectInterval = 1;
        ClientImpl.prototype._reconnecting = false;
        ClientImpl.prototype._reconnectTimeout = null;
        ClientImpl.prototype.disconnectedPublishing = false;
        ClientImpl.prototype.disconnectedBufferSize = 5e3;
        ClientImpl.prototype.receiveBuffer = null;
        ClientImpl.prototype._traceBuffer = null;
        ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;
        ClientImpl.prototype.connect = function(connectOptions) {
          var connectOptionsMasked = this._traceMask(connectOptions, "password");
          this._trace("Client.connect", connectOptionsMasked, this.socket, this.connected);
          if (this.connected)
            throw new Error(format(ERROR.INVALID_STATE, ["already connected"]));
          if (this.socket)
            throw new Error(format(ERROR.INVALID_STATE, ["already connected"]));
          if (this._reconnecting) {
            this._reconnectTimeout.cancel();
            this._reconnectTimeout = null;
            this._reconnecting = false;
          }
          this.connectOptions = connectOptions;
          this._reconnectInterval = 1;
          this._reconnecting = false;
          if (connectOptions.uris) {
            this.hostIndex = 0;
            this._doConnect(connectOptions.uris[0]);
          } else {
            this._doConnect(this.uri);
          }
        };
        ClientImpl.prototype.subscribe = function(filter, subscribeOptions) {
          this._trace("Client.subscribe", filter, subscribeOptions);
          if (!this.connected)
            throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
          var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);
          wireMessage.topics = [filter];
          if (subscribeOptions.qos !== void 0)
            wireMessage.requestedQos = [subscribeOptions.qos];
          else
            wireMessage.requestedQos = [0];
          if (subscribeOptions.onSuccess) {
            wireMessage.onSuccess = function(grantedQos) {
              subscribeOptions.onSuccess({ invocationContext: subscribeOptions.invocationContext, grantedQos });
            };
          }
          if (subscribeOptions.onFailure) {
            wireMessage.onFailure = function(errorCode) {
              subscribeOptions.onFailure({ invocationContext: subscribeOptions.invocationContext, errorCode, errorMessage: format(errorCode) });
            };
          }
          if (subscribeOptions.timeout) {
            wireMessage.timeOut = new Timeout(
              this,
              subscribeOptions.timeout,
              subscribeOptions.onFailure,
              [{
                invocationContext: subscribeOptions.invocationContext,
                errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,
                errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)
              }]
            );
          }
          this._requires_ack(wireMessage);
          this._schedule_message(wireMessage);
        };
        ClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {
          this._trace("Client.unsubscribe", filter, unsubscribeOptions);
          if (!this.connected)
            throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
          var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);
          wireMessage.topics = [filter];
          if (unsubscribeOptions.onSuccess) {
            wireMessage.callback = function() {
              unsubscribeOptions.onSuccess({ invocationContext: unsubscribeOptions.invocationContext });
            };
          }
          if (unsubscribeOptions.timeout) {
            wireMessage.timeOut = new Timeout(
              this,
              unsubscribeOptions.timeout,
              unsubscribeOptions.onFailure,
              [{
                invocationContext: unsubscribeOptions.invocationContext,
                errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,
                errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)
              }]
            );
          }
          this._requires_ack(wireMessage);
          this._schedule_message(wireMessage);
        };
        ClientImpl.prototype.send = function(message) {
          this._trace("Client.send", message);
          var wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);
          wireMessage.payloadMessage = message;
          if (this.connected) {
            if (message.qos > 0) {
              this._requires_ack(wireMessage);
            } else if (this.onMessageDelivered) {
              this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);
            }
            this._schedule_message(wireMessage);
          } else {
            if (this._reconnecting && this.disconnectedPublishing) {
              var messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;
              if (messageCount > this.disconnectedBufferSize) {
                throw new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));
              } else {
                if (message.qos > 0) {
                  this._requires_ack(wireMessage);
                } else {
                  wireMessage.sequence = ++this._sequence;
                  this._buffered_msg_queue.unshift(wireMessage);
                }
              }
            } else {
              throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
            }
          }
        };
        ClientImpl.prototype.disconnect = function() {
          this._trace("Client.disconnect");
          if (this._reconnecting) {
            this._reconnectTimeout.cancel();
            this._reconnectTimeout = null;
            this._reconnecting = false;
          }
          if (!this.socket)
            throw new Error(format(ERROR.INVALID_STATE, ["not connecting or connected"]));
          var wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);
          this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);
          this._schedule_message(wireMessage);
        };
        ClientImpl.prototype.getTraceLog = function() {
          if (this._traceBuffer !== null) {
            this._trace("Client.getTraceLog", new Date());
            this._trace("Client.getTraceLog in flight messages", this._sentMessages.length);
            for (var key in this._sentMessages)
              this._trace("_sentMessages ", key, this._sentMessages[key]);
            for (var key in this._receivedMessages)
              this._trace("_receivedMessages ", key, this._receivedMessages[key]);
            return this._traceBuffer;
          }
        };
        ClientImpl.prototype.startTrace = function() {
          if (this._traceBuffer === null) {
            this._traceBuffer = [];
          }
          this._trace("Client.startTrace", new Date(), version2);
        };
        ClientImpl.prototype.stopTrace = function() {
          delete this._traceBuffer;
        };
        ClientImpl.prototype._doConnect = function(wsurl) {
          if (this.connectOptions.useSSL) {
            var uriParts = wsurl.split(":");
            uriParts[0] = "wss";
            wsurl = uriParts.join(":");
          }
          this._wsuri = wsurl;
          this.connected = false;
          if (this.connectOptions.mqttVersion < 4) {
            this.socket = new WebSocket(wsurl, ["mqttv3.1"]);
          } else {
            this.socket = new WebSocket(wsurl, ["mqtt"]);
          }
          this.socket.binaryType = "arraybuffer";
          this.socket.onopen = scope(this._on_socket_open, this);
          this.socket.onmessage = scope(this._on_socket_message, this);
          this.socket.onerror = scope(this._on_socket_error, this);
          this.socket.onclose = scope(this._on_socket_close, this);
          this.sendPinger = new Pinger(this, this.connectOptions.keepAliveInterval);
          this.receivePinger = new Pinger(this, this.connectOptions.keepAliveInterval);
          if (this._connectTimeout) {
            this._connectTimeout.cancel();
            this._connectTimeout = null;
          }
          this._connectTimeout = new Timeout(this, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);
        };
        ClientImpl.prototype._schedule_message = function(message) {
          this._msg_queue.unshift(message);
          if (this.connected) {
            this._process_queue();
          }
        };
        ClientImpl.prototype.store = function(prefix, wireMessage) {
          var storedMessage = { type: wireMessage.type, messageIdentifier: wireMessage.messageIdentifier, version: 1 };
          switch (wireMessage.type) {
            case MESSAGE_TYPE.PUBLISH:
              if (wireMessage.pubRecReceived)
                storedMessage.pubRecReceived = true;
              storedMessage.payloadMessage = {};
              var hex = "";
              var messageBytes = wireMessage.payloadMessage.payloadBytes;
              for (var i = 0; i < messageBytes.length; i++) {
                if (messageBytes[i] <= 15)
                  hex = hex + "0" + messageBytes[i].toString(16);
                else
                  hex = hex + messageBytes[i].toString(16);
              }
              storedMessage.payloadMessage.payloadHex = hex;
              storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;
              storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;
              if (wireMessage.payloadMessage.duplicate)
                storedMessage.payloadMessage.duplicate = true;
              if (wireMessage.payloadMessage.retained)
                storedMessage.payloadMessage.retained = true;
              if (prefix.indexOf("Sent:") === 0) {
                if (wireMessage.sequence === void 0)
                  wireMessage.sequence = ++this._sequence;
                storedMessage.sequence = wireMessage.sequence;
              }
              break;
            default:
              throw Error(format(ERROR.INVALID_STORED_DATA, [prefix + this._localKey + wireMessage.messageIdentifier, storedMessage]));
          }
          localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));
        };
        ClientImpl.prototype.restore = function(key) {
          var value = localStorage.getItem(key);
          var storedMessage = JSON.parse(value);
          var wireMessage = new WireMessage(storedMessage.type, storedMessage);
          switch (storedMessage.type) {
            case MESSAGE_TYPE.PUBLISH:
              var hex = storedMessage.payloadMessage.payloadHex;
              var buffer = new ArrayBuffer(hex.length / 2);
              var byteStream = new Uint8Array(buffer);
              var i = 0;
              while (hex.length >= 2) {
                var x = parseInt(hex.substring(0, 2), 16);
                hex = hex.substring(2, hex.length);
                byteStream[i++] = x;
              }
              var payloadMessage = new PahoMQTT.Message(byteStream);
              payloadMessage.qos = storedMessage.payloadMessage.qos;
              payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;
              if (storedMessage.payloadMessage.duplicate)
                payloadMessage.duplicate = true;
              if (storedMessage.payloadMessage.retained)
                payloadMessage.retained = true;
              wireMessage.payloadMessage = payloadMessage;
              break;
            default:
              throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));
          }
          if (key.indexOf("Sent:" + this._localKey) === 0) {
            wireMessage.payloadMessage.duplicate = true;
            this._sentMessages[wireMessage.messageIdentifier] = wireMessage;
          } else if (key.indexOf("Received:" + this._localKey) === 0) {
            this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
          }
        };
        ClientImpl.prototype._process_queue = function() {
          var message = null;
          while (message = this._msg_queue.pop()) {
            this._socket_send(message);
            if (this._notify_msg_sent[message]) {
              this._notify_msg_sent[message]();
              delete this._notify_msg_sent[message];
            }
          }
        };
        ClientImpl.prototype._requires_ack = function(wireMessage) {
          var messageCount = Object.keys(this._sentMessages).length;
          if (messageCount > this.maxMessageIdentifier)
            throw Error("Too many messages:" + messageCount);
          while (this._sentMessages[this._message_identifier] !== void 0) {
            this._message_identifier++;
          }
          wireMessage.messageIdentifier = this._message_identifier;
          this._sentMessages[wireMessage.messageIdentifier] = wireMessage;
          if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {
            this.store("Sent:", wireMessage);
          }
          if (this._message_identifier === this.maxMessageIdentifier) {
            this._message_identifier = 1;
          }
        };
        ClientImpl.prototype._on_socket_open = function() {
          var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);
          wireMessage.clientId = this.clientId;
          this._socket_send(wireMessage);
        };
        ClientImpl.prototype._on_socket_message = function(event) {
          this._trace("Client._on_socket_message", event.data);
          var messages = this._deframeMessages(event.data);
          for (var i = 0; i < messages.length; i += 1) {
            this._handleMessage(messages[i]);
          }
        };
        ClientImpl.prototype._deframeMessages = function(data) {
          var byteArray = new Uint8Array(data);
          var messages = [];
          if (this.receiveBuffer) {
            var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);
            newData.set(this.receiveBuffer);
            newData.set(byteArray, this.receiveBuffer.length);
            byteArray = newData;
            delete this.receiveBuffer;
          }
          try {
            var offset = 0;
            while (offset < byteArray.length) {
              var result = decodeMessage(byteArray, offset);
              var wireMessage = result[0];
              offset = result[1];
              if (wireMessage !== null) {
                messages.push(wireMessage);
              } else {
                break;
              }
            }
            if (offset < byteArray.length) {
              this.receiveBuffer = byteArray.subarray(offset);
            }
          } catch (error) {
            var errorStack = error.hasOwnProperty("stack") == "undefined" ? error.stack.toString() : "No Error Stack Available";
            this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
            return;
          }
          return messages;
        };
        ClientImpl.prototype._handleMessage = function(wireMessage) {
          this._trace("Client._handleMessage", wireMessage);
          try {
            switch (wireMessage.type) {
              case MESSAGE_TYPE.CONNACK:
                this._connectTimeout.cancel();
                if (this._reconnectTimeout)
                  this._reconnectTimeout.cancel();
                if (this.connectOptions.cleanSession) {
                  for (var key in this._sentMessages) {
                    var sentMessage = this._sentMessages[key];
                    localStorage.removeItem("Sent:" + this._localKey + sentMessage.messageIdentifier);
                  }
                  this._sentMessages = {};
                  for (var key in this._receivedMessages) {
                    var receivedMessage = this._receivedMessages[key];
                    localStorage.removeItem("Received:" + this._localKey + receivedMessage.messageIdentifier);
                  }
                  this._receivedMessages = {};
                }
                if (wireMessage.returnCode === 0) {
                  this.connected = true;
                  if (this.connectOptions.uris)
                    this.hostIndex = this.connectOptions.uris.length;
                } else {
                  this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));
                  break;
                }
                var sequencedMessages = [];
                for (var msgId in this._sentMessages) {
                  if (this._sentMessages.hasOwnProperty(msgId))
                    sequencedMessages.push(this._sentMessages[msgId]);
                }
                if (this._buffered_msg_queue.length > 0) {
                  var msg = null;
                  while (msg = this._buffered_msg_queue.pop()) {
                    sequencedMessages.push(msg);
                    if (this.onMessageDelivered)
                      this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);
                  }
                }
                var sequencedMessages = sequencedMessages.sort(function(a, b) {
                  return a.sequence - b.sequence;
                });
                for (var i = 0, len = sequencedMessages.length; i < len; i++) {
                  var sentMessage = sequencedMessages[i];
                  if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {
                    var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: sentMessage.messageIdentifier });
                    this._schedule_message(pubRelMessage);
                  } else {
                    this._schedule_message(sentMessage);
                  }
                }
                if (this.connectOptions.onSuccess) {
                  this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext });
                }
                var reconnected = false;
                if (this._reconnecting) {
                  reconnected = true;
                  this._reconnectInterval = 1;
                  this._reconnecting = false;
                }
                this._connected(reconnected, this._wsuri);
                this._process_queue();
                break;
              case MESSAGE_TYPE.PUBLISH:
                this._receivePublish(wireMessage);
                break;
              case MESSAGE_TYPE.PUBACK:
                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
                if (sentMessage) {
                  delete this._sentMessages[wireMessage.messageIdentifier];
                  localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
                  if (this.onMessageDelivered)
                    this.onMessageDelivered(sentMessage.payloadMessage);
                }
                break;
              case MESSAGE_TYPE.PUBREC:
                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
                if (sentMessage) {
                  sentMessage.pubRecReceived = true;
                  var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier: wireMessage.messageIdentifier });
                  this.store("Sent:", sentMessage);
                  this._schedule_message(pubRelMessage);
                }
                break;
              case MESSAGE_TYPE.PUBREL:
                var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];
                localStorage.removeItem("Received:" + this._localKey + wireMessage.messageIdentifier);
                if (receivedMessage) {
                  this._receiveMessage(receivedMessage);
                  delete this._receivedMessages[wireMessage.messageIdentifier];
                }
                var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, { messageIdentifier: wireMessage.messageIdentifier });
                this._schedule_message(pubCompMessage);
                break;
              case MESSAGE_TYPE.PUBCOMP:
                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
                delete this._sentMessages[wireMessage.messageIdentifier];
                localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
                if (this.onMessageDelivered)
                  this.onMessageDelivered(sentMessage.payloadMessage);
                break;
              case MESSAGE_TYPE.SUBACK:
                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
                if (sentMessage) {
                  if (sentMessage.timeOut)
                    sentMessage.timeOut.cancel();
                  if (wireMessage.returnCode[0] === 128) {
                    if (sentMessage.onFailure) {
                      sentMessage.onFailure(wireMessage.returnCode);
                    }
                  } else if (sentMessage.onSuccess) {
                    sentMessage.onSuccess(wireMessage.returnCode);
                  }
                  delete this._sentMessages[wireMessage.messageIdentifier];
                }
                break;
              case MESSAGE_TYPE.UNSUBACK:
                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
                if (sentMessage) {
                  if (sentMessage.timeOut)
                    sentMessage.timeOut.cancel();
                  if (sentMessage.callback) {
                    sentMessage.callback();
                  }
                  delete this._sentMessages[wireMessage.messageIdentifier];
                }
                break;
              case MESSAGE_TYPE.PINGRESP:
                this.sendPinger.reset();
                break;
              case MESSAGE_TYPE.DISCONNECT:
                this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
                break;
              default:
                this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
            }
          } catch (error) {
            var errorStack = error.hasOwnProperty("stack") == "undefined" ? error.stack.toString() : "No Error Stack Available";
            this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
            return;
          }
        };
        ClientImpl.prototype._on_socket_error = function(error) {
          if (!this._reconnecting) {
            this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));
          }
        };
        ClientImpl.prototype._on_socket_close = function() {
          if (!this._reconnecting) {
            this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));
          }
        };
        ClientImpl.prototype._socket_send = function(wireMessage) {
          if (wireMessage.type == 1) {
            var wireMessageMasked = this._traceMask(wireMessage, "password");
            this._trace("Client._socket_send", wireMessageMasked);
          } else
            this._trace("Client._socket_send", wireMessage);
          this.socket.send(wireMessage.encode());
          this.sendPinger.reset();
        };
        ClientImpl.prototype._receivePublish = function(wireMessage) {
          switch (wireMessage.payloadMessage.qos) {
            case "undefined":
            case 0:
              this._receiveMessage(wireMessage);
              break;
            case 1:
              var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, { messageIdentifier: wireMessage.messageIdentifier });
              this._schedule_message(pubAckMessage);
              this._receiveMessage(wireMessage);
              break;
            case 2:
              this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
              this.store("Received:", wireMessage);
              var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, { messageIdentifier: wireMessage.messageIdentifier });
              this._schedule_message(pubRecMessage);
              break;
            default:
              throw Error("Invaild qos=" + wireMessage.payloadMessage.qos);
          }
        };
        ClientImpl.prototype._receiveMessage = function(wireMessage) {
          if (this.onMessageArrived) {
            this.onMessageArrived(wireMessage.payloadMessage);
          }
        };
        ClientImpl.prototype._connected = function(reconnect, uri) {
          if (this.onConnected)
            this.onConnected(reconnect, uri);
        };
        ClientImpl.prototype._reconnect = function() {
          this._trace("Client._reconnect");
          if (!this.connected) {
            this._reconnecting = true;
            this.sendPinger.cancel();
            this.receivePinger.cancel();
            if (this._reconnectInterval < 128)
              this._reconnectInterval = this._reconnectInterval * 2;
            if (this.connectOptions.uris) {
              this.hostIndex = 0;
              this._doConnect(this.connectOptions.uris[0]);
            } else {
              this._doConnect(this.uri);
            }
          }
        };
        ClientImpl.prototype._disconnected = function(errorCode, errorText) {
          this._trace("Client._disconnected", errorCode, errorText);
          if (errorCode !== void 0 && this._reconnecting) {
            this._reconnectTimeout = new Timeout(this, this._reconnectInterval, this._reconnect);
            return;
          }
          this.sendPinger.cancel();
          this.receivePinger.cancel();
          if (this._connectTimeout) {
            this._connectTimeout.cancel();
            this._connectTimeout = null;
          }
          this._msg_queue = [];
          this._buffered_msg_queue = [];
          this._notify_msg_sent = {};
          if (this.socket) {
            this.socket.onopen = null;
            this.socket.onmessage = null;
            this.socket.onerror = null;
            this.socket.onclose = null;
            if (this.socket.readyState === 1)
              this.socket.close();
            delete this.socket;
          }
          if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {
            this.hostIndex++;
            this._doConnect(this.connectOptions.uris[this.hostIndex]);
          } else {
            if (errorCode === void 0) {
              errorCode = ERROR.OK.code;
              errorText = format(ERROR.OK);
            }
            if (this.connected) {
              this.connected = false;
              if (this.onConnectionLost) {
                this.onConnectionLost({ errorCode, errorMessage: errorText, reconnect: this.connectOptions.reconnect, uri: this._wsuri });
              }
              if (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {
                this._reconnectInterval = 1;
                this._reconnect();
                return;
              }
            } else {
              if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {
                this._trace("Failed to connect V4, dropping back to V3");
                this.connectOptions.mqttVersion = 3;
                if (this.connectOptions.uris) {
                  this.hostIndex = 0;
                  this._doConnect(this.connectOptions.uris[0]);
                } else {
                  this._doConnect(this.uri);
                }
              } else if (this.connectOptions.onFailure) {
                this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode, errorMessage: errorText });
              }
            }
          }
        };
        ClientImpl.prototype._trace = function() {
          if (this.traceFunction) {
            var args = Array.prototype.slice.call(arguments);
            for (var i in args) {
              if (typeof args[i] !== "undefined")
                args.splice(i, 1, JSON.stringify(args[i]));
            }
            var record = args.join("");
            this.traceFunction({ severity: "Debug", message: record });
          }
          if (this._traceBuffer !== null) {
            for (var i = 0, max = arguments.length; i < max; i++) {
              if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {
                this._traceBuffer.shift();
              }
              if (i === 0)
                this._traceBuffer.push(arguments[i]);
              else if (typeof arguments[i] === "undefined")
                this._traceBuffer.push(arguments[i]);
              else
                this._traceBuffer.push("  " + JSON.stringify(arguments[i]));
            }
          }
        };
        ClientImpl.prototype._traceMask = function(traceObject, masked) {
          var traceObjectMasked = {};
          for (var attr in traceObject) {
            if (traceObject.hasOwnProperty(attr)) {
              if (attr == masked)
                traceObjectMasked[attr] = "******";
              else
                traceObjectMasked[attr] = traceObject[attr];
            }
          }
          return traceObjectMasked;
        };
        var Client = function(host, port, path, clientId) {
          var uri;
          if (typeof host !== "string")
            throw new Error(format(ERROR.INVALID_TYPE, [typeof host, "host"]));
          if (arguments.length == 2) {
            clientId = port;
            uri = host;
            var match = uri.match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/);
            if (match) {
              host = match[4] || match[2];
              port = parseInt(match[7]);
              path = match[8];
            } else {
              throw new Error(format(ERROR.INVALID_ARGUMENT, [host, "host"]));
            }
          } else {
            if (arguments.length == 3) {
              clientId = path;
              path = "/mqtt";
            }
            if (typeof port !== "number" || port < 0)
              throw new Error(format(ERROR.INVALID_TYPE, [typeof port, "port"]));
            if (typeof path !== "string")
              throw new Error(format(ERROR.INVALID_TYPE, [typeof path, "path"]));
            var ipv6AddSBracket = host.indexOf(":") !== -1 && host.slice(0, 1) !== "[" && host.slice(-1) !== "]";
            uri = "ws://" + (ipv6AddSBracket ? "[" + host + "]" : host) + ":" + port + path;
          }
          var clientIdLength = 0;
          for (var i = 0; i < clientId.length; i++) {
            var charCode = clientId.charCodeAt(i);
            if (55296 <= charCode && charCode <= 56319) {
              i++;
            }
            clientIdLength++;
          }
          if (typeof clientId !== "string" || clientIdLength > 65535)
            throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, "clientId"]));
          var client = new ClientImpl(uri, host, port, path, clientId);
          Object.defineProperties(this, {
            "host": {
              get: function() {
                return host;
              },
              set: function() {
                throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
              }
            },
            "port": {
              get: function() {
                return port;
              },
              set: function() {
                throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
              }
            },
            "path": {
              get: function() {
                return path;
              },
              set: function() {
                throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
              }
            },
            "uri": {
              get: function() {
                return uri;
              },
              set: function() {
                throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
              }
            },
            "clientId": {
              get: function() {
                return client.clientId;
              },
              set: function() {
                throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
              }
            },
            "onConnected": {
              get: function() {
                return client.onConnected;
              },
              set: function(newOnConnected) {
                if (typeof newOnConnected === "function")
                  client.onConnected = newOnConnected;
                else
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnected, "onConnected"]));
              }
            },
            "disconnectedPublishing": {
              get: function() {
                return client.disconnectedPublishing;
              },
              set: function(newDisconnectedPublishing) {
                client.disconnectedPublishing = newDisconnectedPublishing;
              }
            },
            "disconnectedBufferSize": {
              get: function() {
                return client.disconnectedBufferSize;
              },
              set: function(newDisconnectedBufferSize) {
                client.disconnectedBufferSize = newDisconnectedBufferSize;
              }
            },
            "onConnectionLost": {
              get: function() {
                return client.onConnectionLost;
              },
              set: function(newOnConnectionLost) {
                if (typeof newOnConnectionLost === "function")
                  client.onConnectionLost = newOnConnectionLost;
                else
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, "onConnectionLost"]));
              }
            },
            "onMessageDelivered": {
              get: function() {
                return client.onMessageDelivered;
              },
              set: function(newOnMessageDelivered) {
                if (typeof newOnMessageDelivered === "function")
                  client.onMessageDelivered = newOnMessageDelivered;
                else
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, "onMessageDelivered"]));
              }
            },
            "onMessageArrived": {
              get: function() {
                return client.onMessageArrived;
              },
              set: function(newOnMessageArrived) {
                if (typeof newOnMessageArrived === "function")
                  client.onMessageArrived = newOnMessageArrived;
                else
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, "onMessageArrived"]));
              }
            },
            "trace": {
              get: function() {
                return client.traceFunction;
              },
              set: function(trace) {
                if (typeof trace === "function") {
                  client.traceFunction = trace;
                } else {
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, "onTrace"]));
                }
              }
            }
          });
          this.connect = function(connectOptions) {
            connectOptions = connectOptions || {};
            validate2(connectOptions, {
              timeout: "number",
              userName: "string",
              password: "string",
              willMessage: "object",
              keepAliveInterval: "number",
              cleanSession: "boolean",
              useSSL: "boolean",
              invocationContext: "object",
              onSuccess: "function",
              onFailure: "function",
              hosts: "object",
              ports: "object",
              reconnect: "boolean",
              mqttVersion: "number",
              mqttVersionExplicit: "boolean",
              uris: "object"
            });
            if (connectOptions.keepAliveInterval === void 0)
              connectOptions.keepAliveInterval = 60;
            if (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {
              throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, "connectOptions.mqttVersion"]));
            }
            if (connectOptions.mqttVersion === void 0) {
              connectOptions.mqttVersionExplicit = false;
              connectOptions.mqttVersion = 4;
            } else {
              connectOptions.mqttVersionExplicit = true;
            }
            if (connectOptions.password !== void 0 && connectOptions.userName === void 0)
              throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, "connectOptions.password"]));
            if (connectOptions.willMessage) {
              if (!(connectOptions.willMessage instanceof Message))
                throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, "connectOptions.willMessage"]));
              connectOptions.willMessage.stringPayload = null;
              if (typeof connectOptions.willMessage.destinationName === "undefined")
                throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, "connectOptions.willMessage.destinationName"]));
            }
            if (typeof connectOptions.cleanSession === "undefined")
              connectOptions.cleanSession = true;
            if (connectOptions.hosts) {
              if (!(connectOptions.hosts instanceof Array))
                throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
              if (connectOptions.hosts.length < 1)
                throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
              var usingURIs = false;
              for (var i2 = 0; i2 < connectOptions.hosts.length; i2++) {
                if (typeof connectOptions.hosts[i2] !== "string")
                  throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i2], "connectOptions.hosts[" + i2 + "]"]));
                if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(connectOptions.hosts[i2])) {
                  if (i2 === 0) {
                    usingURIs = true;
                  } else if (!usingURIs) {
                    throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i2], "connectOptions.hosts[" + i2 + "]"]));
                  }
                } else if (usingURIs) {
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i2], "connectOptions.hosts[" + i2 + "]"]));
                }
              }
              if (!usingURIs) {
                if (!connectOptions.ports)
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
                if (!(connectOptions.ports instanceof Array))
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
                if (connectOptions.hosts.length !== connectOptions.ports.length)
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
                connectOptions.uris = [];
                for (var i2 = 0; i2 < connectOptions.hosts.length; i2++) {
                  if (typeof connectOptions.ports[i2] !== "number" || connectOptions.ports[i2] < 0)
                    throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i2], "connectOptions.ports[" + i2 + "]"]));
                  var host2 = connectOptions.hosts[i2];
                  var port2 = connectOptions.ports[i2];
                  var ipv6 = host2.indexOf(":") !== -1;
                  uri = "ws://" + (ipv6 ? "[" + host2 + "]" : host2) + ":" + port2 + path;
                  connectOptions.uris.push(uri);
                }
              } else {
                connectOptions.uris = connectOptions.hosts;
              }
            }
            client.connect(connectOptions);
          };
          this.subscribe = function(filter, subscribeOptions) {
            if (typeof filter !== "string")
              throw new Error("Invalid argument:" + filter);
            subscribeOptions = subscribeOptions || {};
            validate2(subscribeOptions, {
              qos: "number",
              invocationContext: "object",
              onSuccess: "function",
              onFailure: "function",
              timeout: "number"
            });
            if (subscribeOptions.timeout && !subscribeOptions.onFailure)
              throw new Error("subscribeOptions.timeout specified with no onFailure callback.");
            if (typeof subscribeOptions.qos !== "undefined" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2))
              throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, "subscribeOptions.qos"]));
            client.subscribe(filter, subscribeOptions);
          };
          this.unsubscribe = function(filter, unsubscribeOptions) {
            if (typeof filter !== "string")
              throw new Error("Invalid argument:" + filter);
            unsubscribeOptions = unsubscribeOptions || {};
            validate2(unsubscribeOptions, {
              invocationContext: "object",
              onSuccess: "function",
              onFailure: "function",
              timeout: "number"
            });
            if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)
              throw new Error("unsubscribeOptions.timeout specified with no onFailure callback.");
            client.unsubscribe(filter, unsubscribeOptions);
          };
          this.send = function(topic, payload, qos, retained) {
            var message;
            if (arguments.length === 0) {
              throw new Error("Invalid argument.length");
            } else if (arguments.length == 1) {
              if (!(topic instanceof Message) && typeof topic !== "string")
                throw new Error("Invalid argument:" + typeof topic);
              message = topic;
              if (typeof message.destinationName === "undefined")
                throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
              client.send(message);
            } else {
              message = new Message(payload);
              message.destinationName = topic;
              if (arguments.length >= 3)
                message.qos = qos;
              if (arguments.length >= 4)
                message.retained = retained;
              client.send(message);
            }
          };
          this.publish = function(topic, payload, qos, retained) {
            var message;
            if (arguments.length === 0) {
              throw new Error("Invalid argument.length");
            } else if (arguments.length == 1) {
              if (!(topic instanceof Message) && typeof topic !== "string")
                throw new Error("Invalid argument:" + typeof topic);
              message = topic;
              if (typeof message.destinationName === "undefined")
                throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
              client.send(message);
            } else {
              message = new Message(payload);
              message.destinationName = topic;
              if (arguments.length >= 3)
                message.qos = qos;
              if (arguments.length >= 4)
                message.retained = retained;
              client.send(message);
            }
          };
          this.disconnect = function() {
            client.disconnect();
          };
          this.getTraceLog = function() {
            return client.getTraceLog();
          };
          this.startTrace = function() {
            client.startTrace();
          };
          this.stopTrace = function() {
            client.stopTrace();
          };
          this.isConnected = function() {
            return client.connected;
          };
        };
        var Message = function(newPayload) {
          var payload;
          if (typeof newPayload === "string" || newPayload instanceof ArrayBuffer || ArrayBuffer.isView(newPayload) && !(newPayload instanceof DataView)) {
            payload = newPayload;
          } else {
            throw format(ERROR.INVALID_ARGUMENT, [newPayload, "newPayload"]);
          }
          var destinationName;
          var qos = 0;
          var retained = false;
          var duplicate = false;
          Object.defineProperties(this, {
            "payloadString": {
              enumerable: true,
              get: function() {
                if (typeof payload === "string")
                  return payload;
                else
                  return parseUTF8(payload, 0, payload.length);
              }
            },
            "payloadBytes": {
              enumerable: true,
              get: function() {
                if (typeof payload === "string") {
                  var buffer = new ArrayBuffer(UTF8Length(payload));
                  var byteStream = new Uint8Array(buffer);
                  stringToUTF8(payload, byteStream, 0);
                  return byteStream;
                } else {
                  return payload;
                }
              }
            },
            "destinationName": {
              enumerable: true,
              get: function() {
                return destinationName;
              },
              set: function(newDestinationName) {
                if (typeof newDestinationName === "string")
                  destinationName = newDestinationName;
                else
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, "newDestinationName"]));
              }
            },
            "qos": {
              enumerable: true,
              get: function() {
                return qos;
              },
              set: function(newQos) {
                if (newQos === 0 || newQos === 1 || newQos === 2)
                  qos = newQos;
                else
                  throw new Error("Invalid argument:" + newQos);
              }
            },
            "retained": {
              enumerable: true,
              get: function() {
                return retained;
              },
              set: function(newRetained) {
                if (typeof newRetained === "boolean")
                  retained = newRetained;
                else
                  throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, "newRetained"]));
              }
            },
            "topic": {
              enumerable: true,
              get: function() {
                return destinationName;
              },
              set: function(newTopic) {
                destinationName = newTopic;
              }
            },
            "duplicate": {
              enumerable: true,
              get: function() {
                return duplicate;
              },
              set: function(newDuplicate) {
                duplicate = newDuplicate;
              }
            }
          });
        };
        return {
          Client,
          Message
        };
      }(typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      return PahoMQTT;
    });
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/subscription-handshake-link.js
var require_subscription_handshake_link = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/subscription-handshake-link.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = (init_core2(), __toCommonJS(core_exports));
    var utils_1 = require_utils();
    var Paho = require_paho_mqtt();
    var utilities_1 = (init_utilities(), __toCommonJS(utilities_exports));
    var logger = utils_1.rootLogger.extend("subscriptions");
    var mqttLogger = logger.extend("mqtt");
    exports.CONTROL_EVENTS_KEY = "@@controlEvents";
    var SubscriptionHandshakeLink = (
      /** @class */
      function(_super) {
        __extends(SubscriptionHandshakeLink2, _super);
        function SubscriptionHandshakeLink2(subsInfoContextKey) {
          var _this = _super.call(this) || this;
          _this.topicObservers = /* @__PURE__ */ new Map();
          _this.clientObservers = /* @__PURE__ */ new Map();
          _this.onMessage = function(topic, message, selectionNames) {
            var parsedMessage = JSON.parse(message);
            var observers = _this.topicObservers.get(topic);
            var data = selectionNames.reduce(function(acc, name) {
              return acc[name] = acc[name] || null, acc;
            }, parsedMessage.data || {});
            logger("Message received", { data, topic, observers });
            observers.forEach(function(observer) {
              try {
                observer.next(__assign(__assign({}, parsedMessage), { data }));
              } catch (err) {
                logger(err);
              }
            });
          };
          _this.subsInfoContextKey = subsInfoContextKey;
          return _this;
        }
        SubscriptionHandshakeLink2.prototype.request = function(operation) {
          var _a;
          var _this = this;
          var _b = operation.getContext(), _c = this.subsInfoContextKey, subsInfo = _b[_c], _d = _b.controlMessages, _e = exports.CONTROL_EVENTS_KEY, controlEvents = (_d === void 0 ? (_a = {}, _a[exports.CONTROL_EVENTS_KEY] = void 0, _a) : _d)[_e];
          var _f = subsInfo.extensions, _g = (_f === void 0 ? { subscription: { newSubscriptions: {}, mqttConnections: [] } } : _f).subscription, newSubscriptions = _g.newSubscriptions, mqttConnections = _g.mqttConnections, _h = subsInfo.errors, errors = _h === void 0 ? [] : _h;
          if (errors && errors.length) {
            return new core_1.Observable(function(observer) {
              observer.error(new core_1.ApolloError({
                errorMessage: "Error during subscription handshake",
                extraInfo: { errors },
                graphQLErrors: errors
              }));
              return function() {
              };
            });
          }
          var newSubscriptionTopics = Object.keys(newSubscriptions).map(function(subKey) {
            return newSubscriptions[subKey].topic;
          });
          var existingTopicsWithObserver = new Set(newSubscriptionTopics.filter(function(t) {
            return _this.topicObservers.has(t);
          }));
          var newTopics = new Set(newSubscriptionTopics.filter(function(t) {
            return !existingTopicsWithObserver.has(t);
          }));
          return new core_1.Observable(function(observer) {
            existingTopicsWithObserver.forEach(function(t) {
              _this.topicObservers.get(t).add(observer);
              var anObserver = Array.from(_this.topicObservers.get(t)).find(function() {
                return true;
              });
              var clientId = Array.from(_this.clientObservers).find(function(_a2) {
                var observers = _a2[1].observers;
                return observers.has(anObserver);
              })[0];
              _this.clientObservers.get(clientId).observers.add(observer);
            });
            var newTopicsConnectionInfo = mqttConnections.filter(function(c) {
              return c.topics.some(function(t) {
                return newTopics.has(t);
              });
            }).map(function(_a2) {
              var topics = _a2.topics, rest = __rest2(_a2, ["topics"]);
              return __assign(__assign({}, rest), { topics: topics.filter(function(t) {
                return newTopics.has(t);
              }) });
            });
            _this.connectNewClients(newTopicsConnectionInfo, observer, operation);
            return function() {
              var clientsForCurrentObserver = Array.from(_this.clientObservers).filter(function(_a2) {
                var observers = _a2[1].observers;
                return observers.has(observer);
              });
              clientsForCurrentObserver.forEach(function(_a2) {
                var clientId = _a2[0];
                return _this.clientObservers.get(clientId).observers.delete(observer);
              });
              _this.clientObservers.forEach(function(_a2) {
                var observers = _a2.observers, client = _a2.client;
                if (observers.size === 0) {
                  if (client.isConnected()) {
                    client.disconnect();
                  }
                  _this.clientObservers.delete(client.clientId);
                }
              });
              _this.clientObservers = new Map(Array.from(_this.clientObservers).filter(function(_a2) {
                var observers = _a2[1].observers;
                return observers.size > 0;
              }));
              _this.topicObservers.forEach(function(observers) {
                return observers.delete(observer);
              });
              _this.topicObservers = new Map(Array.from(_this.topicObservers).filter(function(_a2) {
                var observers = _a2[1];
                return observers.size > 0;
              }));
            };
          }).filter(function(data) {
            var _a2 = data.extensions, _b2 = (_a2 === void 0 ? {} : _a2).controlMsgType, controlMsgType = _b2 === void 0 ? void 0 : _b2;
            var isControlMsg = typeof controlMsgType !== "undefined";
            return controlEvents === true || !isControlMsg;
          });
        };
        SubscriptionHandshakeLink2.prototype.connectNewClients = function(connectionInfo, observer, operation) {
          return __awaiter(this, void 0, void 0, function() {
            var query, selectionNames, result, data;
            var _this = this;
            return __generator(this, function(_a) {
              query = operation.query;
              selectionNames = utilities_1.getMainDefinition(query).selectionSet.selections.map(function(_a2) {
                var value = _a2.name.value;
                return value;
              });
              result = Promise.all(connectionInfo.map(function(c) {
                return _this.connectNewClient(c, observer, selectionNames);
              }));
              data = selectionNames.reduce(function(acc, name) {
                return acc[name] = acc[name] || null, acc;
              }, {});
              observer.next({
                data,
                extensions: {
                  controlMsgType: "CONNECTED",
                  controlMsgInfo: {
                    connectionInfo
                  }
                }
              });
              return [2, result];
            });
          });
        };
        ;
        SubscriptionHandshakeLink2.prototype.connectNewClient = function(connectionInfo, observer, selectionNames) {
          return __awaiter(this, void 0, void 0, function() {
            var clientId, url, topics, client;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  clientId = connectionInfo.client, url = connectionInfo.url, topics = connectionInfo.topics;
                  client = new Paho.Client(url, clientId);
                  client.trace = mqttLogger.bind(null, clientId);
                  client.onConnectionLost = function(_a2) {
                    var errorCode = _a2.errorCode, args = __rest2(_a2, ["errorCode"]);
                    if (errorCode !== 0) {
                      topics.forEach(function(t) {
                        if (_this.topicObservers.has(t)) {
                          _this.topicObservers.get(t).forEach(function(observer2) {
                            return observer2.error(__assign(__assign({}, args), { permanent: true }));
                          });
                        }
                      });
                    }
                    topics.forEach(function(t) {
                      return _this.topicObservers.delete(t);
                    });
                  };
                  client.onMessageArrived = function(_a2) {
                    var destinationName = _a2.destinationName, payloadString = _a2.payloadString;
                    return _this.onMessage(destinationName, payloadString, selectionNames);
                  };
                  return [4, new Promise(function(resolve, reject) {
                    client.connect({
                      useSSL: url.indexOf("wss://") === 0,
                      mqttVersion: 3,
                      onSuccess: function() {
                        return resolve(client);
                      },
                      onFailure: reject
                    });
                  })];
                case 1:
                  _a.sent();
                  return [4, this.subscribeToTopics(client, topics, observer)];
                case 2:
                  _a.sent();
                  return [2, client];
              }
            });
          });
        };
        SubscriptionHandshakeLink2.prototype.subscribeToTopics = function(client, topics, observer) {
          var _this = this;
          return Promise.all(topics.map(function(topic) {
            return _this.subscribeToTopic(client, topic, observer);
          }));
        };
        SubscriptionHandshakeLink2.prototype.subscribeToTopic = function(client, topic, observer) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            client.subscribe(topic, {
              onSuccess: function() {
                if (!_this.topicObservers.has(topic)) {
                  _this.topicObservers.set(topic, /* @__PURE__ */ new Set());
                }
                if (!_this.clientObservers.has(client.clientId)) {
                  _this.clientObservers.set(client.clientId, { client, observers: /* @__PURE__ */ new Set() });
                }
                _this.topicObservers.get(topic).add(observer);
                _this.clientObservers.get(client.clientId).observers.add(observer);
                resolve(topic);
              },
              onFailure: reject
            });
          });
        };
        return SubscriptionHandshakeLink2;
      }(core_1.ApolloLink)
    );
    exports.SubscriptionHandshakeLink = SubscriptionHandshakeLink;
  }
});

// ../../node_modules/@apollo/client/link/context/index.js
var context_exports = {};
__export(context_exports, {
  setContext: () => setContext
});
function setContext(setter) {
  return new ApolloLink(function(operation, forward) {
    var request = __rest(operation, []);
    return new Observable(function(observer) {
      var handle;
      var closed = false;
      Promise.resolve(request).then(function(req) {
        return setter(req, operation.getContext());
      }).then(operation.setContext).then(function() {
        if (closed)
          return;
        handle = forward(operation).subscribe({
          next: observer.next.bind(observer),
          error: observer.error.bind(observer),
          complete: observer.complete.bind(observer)
        });
      }).catch(observer.error.bind(observer));
      return function() {
        closed = true;
        if (handle)
          handle.unsubscribe();
      };
    });
  });
}
var init_context = __esm({
  "../../node_modules/@apollo/client/link/context/index.js"() {
    init_tslib_es6();
    init_core();
    init_utilities();
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/non-terminating-link.js
var require_non_terminating_link = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/non-terminating-link.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = (init_core2(), __toCommonJS(core_exports));
    var context_1 = (init_context(), __toCommonJS(context_exports));
    var NonTerminatingLink = (
      /** @class */
      function(_super) {
        __extends(NonTerminatingLink2, _super);
        function NonTerminatingLink2(contextKey, _a) {
          var link = _a.link;
          var _this = _super.call(this) || this;
          _this.contextKey = contextKey;
          _this.link = link;
          return _this;
        }
        NonTerminatingLink2.prototype.request = function(operation, forward) {
          var _this = this;
          return context_1.setContext(function(_request, prevContext) {
            return __awaiter(_this, void 0, void 0, function() {
              var result;
              var _a;
              var _this2 = this;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    return [4, new Promise(function(resolve, reject) {
                      _this2.link.request(operation).subscribe({
                        next: resolve,
                        error: reject
                      });
                    })];
                  case 1:
                    result = _b.sent();
                    return [2, __assign(__assign({}, prevContext), (_a = {}, _a[this.contextKey] = result, _a))];
                }
              });
            });
          }).request(operation, forward);
        };
        return NonTerminatingLink2;
      }(core_1.ApolloLink)
    );
    exports.NonTerminatingLink = NonTerminatingLink;
  }
});

// ../../node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "../../node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// ../../node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "../../node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// ../../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "../../node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// ../../node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "../../node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// ../../node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "../../node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// ../../node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "../../node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// ../../node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "../../node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// ../../node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "../../node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// ../../node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "../../node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// ../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../../node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../../node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "../../node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// ../../node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "../../node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// ../../node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "../../node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// ../../node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "../../node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// ../../node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "../../node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/types/index.js
var require_types = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SUBSCRIPTION_STATUS;
    (function(SUBSCRIPTION_STATUS2) {
      SUBSCRIPTION_STATUS2[SUBSCRIPTION_STATUS2["PENDING"] = 0] = "PENDING";
      SUBSCRIPTION_STATUS2[SUBSCRIPTION_STATUS2["CONNECTED"] = 1] = "CONNECTED";
      SUBSCRIPTION_STATUS2[SUBSCRIPTION_STATUS2["FAILED"] = 2] = "FAILED";
    })(SUBSCRIPTION_STATUS = exports.SUBSCRIPTION_STATUS || (exports.SUBSCRIPTION_STATUS = {}));
    var SOCKET_STATUS;
    (function(SOCKET_STATUS2) {
      SOCKET_STATUS2[SOCKET_STATUS2["CLOSED"] = 0] = "CLOSED";
      SOCKET_STATUS2[SOCKET_STATUS2["READY"] = 1] = "READY";
      SOCKET_STATUS2[SOCKET_STATUS2["CONNECTING"] = 2] = "CONNECTING";
    })(SOCKET_STATUS = exports.SOCKET_STATUS || (exports.SOCKET_STATUS = {}));
    var MESSAGE_TYPES;
    (function(MESSAGE_TYPES2) {
      MESSAGE_TYPES2["GQL_CONNECTION_INIT"] = "connection_init";
      MESSAGE_TYPES2["GQL_CONNECTION_ERROR"] = "connection_error";
      MESSAGE_TYPES2["GQL_CONNECTION_ACK"] = "connection_ack";
      MESSAGE_TYPES2["GQL_START"] = "start";
      MESSAGE_TYPES2["GQL_START_ACK"] = "start_ack";
      MESSAGE_TYPES2["GQL_DATA"] = "data";
      MESSAGE_TYPES2["GQL_CONNECTION_KEEP_ALIVE"] = "ka";
      MESSAGE_TYPES2["GQL_STOP"] = "stop";
      MESSAGE_TYPES2["GQL_COMPLETE"] = "complete";
      MESSAGE_TYPES2["GQL_ERROR"] = "error";
    })(MESSAGE_TYPES = exports.MESSAGE_TYPES || (exports.MESSAGE_TYPES = {}));
    var CONTROL_MSG;
    (function(CONTROL_MSG2) {
      CONTROL_MSG2["CONNECTION_CLOSED"] = "Connection closed";
      CONTROL_MSG2["TIMEOUT_DISCONNECT"] = "Timeout disconnect";
      CONTROL_MSG2["SUBSCRIPTION_ACK"] = "Subscription ack";
    })(CONTROL_MSG = exports.CONTROL_MSG || (exports.CONTROL_MSG = {}));
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/utils/retry.js
var require_retry = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/utils/retry.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_utils();
    var logger = index_1.rootLogger.extend("retry");
    var MAX_DELAY_MS = 5e3;
    var NonRetryableError = (
      /** @class */
      function(_super) {
        __extends(NonRetryableError2, _super);
        function NonRetryableError2(message) {
          var _this = _super.call(this, message) || this;
          _this.nonRetryable = true;
          return _this;
        }
        return NonRetryableError2;
      }(Error)
    );
    exports.NonRetryableError = NonRetryableError;
    var isNonRetryableError = function(obj) {
      var key = "nonRetryable";
      return obj && obj[key];
    };
    function retry(functionToRetry, args, delayFn, attempt) {
      if (attempt === void 0) {
        attempt = 1;
      }
      return __awaiter(this, void 0, void 0, function() {
        var err_1, retryIn_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              logger("Attempt #" + attempt + " for this vars: " + JSON.stringify(args));
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, , 8]);
              return [4, functionToRetry.apply(void 0, args)];
            case 2:
              _a.sent();
              return [3, 8];
            case 3:
              err_1 = _a.sent();
              logger("error " + err_1);
              if (isNonRetryableError(err_1)) {
                logger("non retryable error");
                throw err_1;
              }
              retryIn_1 = delayFn(attempt, args, err_1);
              logger("retryIn ", retryIn_1);
              if (!(retryIn_1 !== false))
                return [3, 6];
              return [4, new Promise(function(res) {
                return setTimeout(res, retryIn_1);
              })];
            case 4:
              _a.sent();
              return [4, retry(functionToRetry, args, delayFn, attempt + 1)];
            case 5:
              return [2, _a.sent()];
            case 6:
              throw err_1;
            case 7:
              return [3, 8];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.retry = retry;
    function jitteredBackoff(maxDelayMs) {
      var BASE_TIME_MS = 100;
      var JITTER_FACTOR = 100;
      return function(attempt) {
        var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();
        return delay > maxDelayMs ? false : delay;
      };
    }
    exports.jitteredExponentialRetry = function(functionToRetry, args, maxDelayMs) {
      if (maxDelayMs === void 0) {
        maxDelayMs = MAX_DELAY_MS;
      }
      return retry(functionToRetry, args, jitteredBackoff(maxDelayMs));
    };
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/realtime-subscription-handshake-link.js
var require_realtime_subscription_handshake_link = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/realtime-subscription-handshake-link.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = (init_core2(), __toCommonJS(core_exports));
    var utils_1 = require_utils();
    var aws_appsync_auth_link_1 = require_lib();
    var graphql_1 = (init_graphql(), __toCommonJS(graphql_exports));
    var url = require_url();
    var uuid_1 = (init_esm_browser(), __toCommonJS(esm_browser_exports));
    var types_1 = require_types();
    var retry_1 = require_retry();
    var logger = utils_1.rootLogger.extend("subscriptions");
    exports.CONTROL_EVENTS_KEY = "@@controlEvents";
    var NON_RETRYABLE_CODES = [400, 401, 403];
    var SERVICE = "appsync";
    var APPSYNC_REALTIME_HEADERS = {
      accept: "application/json, text/javascript",
      "content-encoding": "amz-1.0",
      "content-type": "application/json; charset=UTF-8"
    };
    var CONNECTION_INIT_TIMEOUT = 15e3;
    var START_ACK_TIMEOUT = 15e3;
    var SERVER_KEEP_ALIVE_TIMEOUT = 1 * 60 * 1e3;
    var DEFAULT_KEEP_ALIVE_TIMEOUT = 5 * 60 * 1e3;
    var standardDomainPattern = /^https:\/\/\w{26}\.appsync\-api\.\w{2}(?:(?:\-\w{2,})+)\-\d\.amazonaws.com\/graphql$/i;
    var customDomainPath = "/realtime";
    var AppSyncRealTimeSubscriptionHandshakeLink = (
      /** @class */
      function(_super) {
        __extends(AppSyncRealTimeSubscriptionHandshakeLink2, _super);
        function AppSyncRealTimeSubscriptionHandshakeLink2(_a) {
          var theUrl = _a.url, theRegion = _a.region, theAuth = _a.auth, keepAliveTimeoutMs = _a.keepAliveTimeoutMs;
          var _this = _super.call(this) || this;
          _this.socketStatus = types_1.SOCKET_STATUS.CLOSED;
          _this.keepAliveTimeout = void 0;
          _this.subscriptionObserverMap = /* @__PURE__ */ new Map();
          _this.promiseArray = [];
          _this.url = theUrl;
          _this.region = theRegion;
          _this.auth = theAuth;
          _this.keepAliveTimeout = keepAliveTimeoutMs;
          if (_this.keepAliveTimeout < SERVER_KEEP_ALIVE_TIMEOUT) {
            var configName = "keepAliveTimeoutMs";
            throw new Error(configName + " must be greater than or equal to " + SERVER_KEEP_ALIVE_TIMEOUT + " (" + _this.keepAliveTimeout + " used).");
          }
          return _this;
        }
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype.isCustomDomain = function(url2) {
          return url2.match(standardDomainPattern) === null;
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype.request = function(operation) {
          var _a;
          var _this = this;
          var query = operation.query, variables = operation.variables;
          var _b = operation.getContext(), _c = _b.controlMessages, _d = exports.CONTROL_EVENTS_KEY, controlEvents = (_c === void 0 ? (_a = {}, _a[exports.CONTROL_EVENTS_KEY] = void 0, _a) : _c)[_d], headers = _b.headers;
          return new core_1.Observable(function(observer) {
            if (!_this.url) {
              observer.error({
                errors: [
                  __assign({}, new graphql_1.GraphQLError("Subscribe only available for AWS AppSync endpoint"))
                ]
              });
              observer.complete();
            } else {
              var subscriptionId_1 = uuid_1.v4();
              var token = _this.auth.type === aws_appsync_auth_link_1.AUTH_TYPE.AMAZON_COGNITO_USER_POOLS || _this.auth.type === aws_appsync_auth_link_1.AUTH_TYPE.OPENID_CONNECT ? _this.auth.jwtToken : null;
              token = _this.auth.type === aws_appsync_auth_link_1.AUTH_TYPE.AWS_LAMBDA ? _this.auth.token : token;
              var options = {
                appSyncGraphqlEndpoint: _this.url,
                authenticationType: _this.auth.type,
                query: graphql_1.print(query),
                region: _this.region,
                graphql_headers: function() {
                  return headers;
                },
                variables,
                apiKey: _this.auth.type === aws_appsync_auth_link_1.AUTH_TYPE.API_KEY ? _this.auth.apiKey : "",
                credentials: _this.auth.type === aws_appsync_auth_link_1.AUTH_TYPE.AWS_IAM ? _this.auth.credentials : null,
                token
              };
              _this._startSubscriptionWithAWSAppSyncRealTime({
                options,
                observer,
                subscriptionId: subscriptionId_1
              });
              return function() {
                return __awaiter(_this, void 0, void 0, function() {
                  var subscriptionState;
                  return __generator(this, function(_a2) {
                    try {
                      this._verifySubscriptionAlreadyStarted(subscriptionId_1);
                      subscriptionState = this.subscriptionObserverMap.get(subscriptionId_1).subscriptionState;
                      if (subscriptionState === types_1.SUBSCRIPTION_STATUS.CONNECTED) {
                        this._sendUnsubscriptionMessage(subscriptionId_1);
                      } else {
                        throw new Error("Subscription has failed, starting to remove subscription.");
                      }
                    } catch (err) {
                      this._removeSubscriptionObserver(subscriptionId_1);
                      return [
                        2
                        /*return*/
                      ];
                    }
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              };
            }
          }).filter(function(data) {
            var _a2 = data.extensions, _b2 = (_a2 === void 0 ? {} : _a2).controlMsgType, controlMsgType = _b2 === void 0 ? void 0 : _b2;
            var isControlMsg = typeof controlMsgType !== "undefined";
            return controlEvents === true || !isControlMsg;
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._verifySubscriptionAlreadyStarted = function(subscriptionId) {
          return __awaiter(this, void 0, void 0, function() {
            var subscriptionState;
            var _this = this;
            return __generator(this, function(_a) {
              subscriptionState = this.subscriptionObserverMap.get(subscriptionId).subscriptionState;
              if (subscriptionState === types_1.SUBSCRIPTION_STATUS.PENDING) {
                return [2, new Promise(function(res, rej) {
                  var _a2 = _this.subscriptionObserverMap.get(subscriptionId), observer = _a2.observer, subscriptionState2 = _a2.subscriptionState, variables = _a2.variables, query = _a2.query;
                  _this.subscriptionObserverMap.set(subscriptionId, {
                    observer,
                    subscriptionState: subscriptionState2,
                    variables,
                    query,
                    subscriptionReadyCallback: res,
                    subscriptionFailedCallback: rej
                  });
                })];
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._sendUnsubscriptionMessage = function(subscriptionId) {
          try {
            if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN && this.socketStatus === types_1.SOCKET_STATUS.READY) {
              var unsubscribeMessage = {
                id: subscriptionId,
                type: types_1.MESSAGE_TYPES.GQL_STOP
              };
              var stringToAWSRealTime = JSON.stringify(unsubscribeMessage);
              this.awsRealTimeSocket.send(stringToAWSRealTime);
              this._removeSubscriptionObserver(subscriptionId);
            }
          } catch (err) {
            logger({ err });
          }
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._removeSubscriptionObserver = function(subscriptionId) {
          this.subscriptionObserverMap.delete(subscriptionId);
          setTimeout(this._closeSocketIfRequired.bind(this), 1e3);
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._closeSocketIfRequired = function() {
          if (this.subscriptionObserverMap.size > 0) {
            return;
          }
          if (!this.awsRealTimeSocket) {
            this.socketStatus = types_1.SOCKET_STATUS.CLOSED;
            return;
          }
          if (this.awsRealTimeSocket.bufferedAmount > 0) {
            setTimeout(this._closeSocketIfRequired.bind(this), 1e3);
          } else {
            logger("closing WebSocket...");
            clearTimeout(this.keepAliveTimeoutId);
            var tempSocket = this.awsRealTimeSocket;
            tempSocket.close(1e3);
            this.awsRealTimeSocket = null;
            this.socketStatus = types_1.SOCKET_STATUS.CLOSED;
          }
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._startSubscriptionWithAWSAppSyncRealTime = function(_a) {
          var options = _a.options, observer = _a.observer, subscriptionId = _a.subscriptionId;
          return __awaiter(this, void 0, void 0, function() {
            var appSyncGraphqlEndpoint, authenticationType, query, variables, apiKey, region, _b, graphql_headers, credentials, token, subscriptionState, data, dataString, headerObj, _c, subscriptionMessage, stringToAWSRealTime, err_1, _d, message, subscriptionFailedCallback_1, _e, subscriptionFailedCallback, subscriptionReadyCallback;
            var _f;
            var _this = this;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  appSyncGraphqlEndpoint = options.appSyncGraphqlEndpoint, authenticationType = options.authenticationType, query = options.query, variables = options.variables, apiKey = options.apiKey, region = options.region, _b = options.graphql_headers, graphql_headers = _b === void 0 ? function() {
                    return {};
                  } : _b, credentials = options.credentials, token = options.token;
                  subscriptionState = types_1.SUBSCRIPTION_STATUS.PENDING;
                  data = {
                    query,
                    variables
                  };
                  this.subscriptionObserverMap.set(subscriptionId, {
                    observer,
                    query,
                    variables,
                    subscriptionState,
                    startAckTimeoutId: null
                  });
                  dataString = JSON.stringify(data);
                  _c = [{}];
                  return [4, this._awsRealTimeHeaderBasedAuth({
                    apiKey,
                    appSyncGraphqlEndpoint,
                    authenticationType,
                    payload: dataString,
                    canonicalUri: "",
                    region,
                    credentials,
                    token,
                    graphql_headers
                  })];
                case 1:
                  headerObj = __assign.apply(void 0, [__assign.apply(void 0, _c.concat([_g.sent()])), (_f = {}, _f[aws_appsync_auth_link_1.USER_AGENT_HEADER] = aws_appsync_auth_link_1.USER_AGENT, _f)]);
                  subscriptionMessage = {
                    id: subscriptionId,
                    payload: {
                      data: dataString,
                      extensions: {
                        authorization: __assign({}, headerObj)
                      }
                    },
                    type: types_1.MESSAGE_TYPES.GQL_START
                  };
                  stringToAWSRealTime = JSON.stringify(subscriptionMessage);
                  _g.label = 2;
                case 2:
                  _g.trys.push([2, 4, , 5]);
                  return [4, this._initializeWebSocketConnection({
                    apiKey,
                    appSyncGraphqlEndpoint,
                    authenticationType,
                    region,
                    credentials,
                    token
                  })];
                case 3:
                  _g.sent();
                  return [3, 5];
                case 4:
                  err_1 = _g.sent();
                  _d = err_1.message, message = _d === void 0 ? "" : _d;
                  observer.error({
                    errors: [
                      __assign({}, new graphql_1.GraphQLError("Connection failed: " + message))
                    ]
                  });
                  observer.complete();
                  subscriptionFailedCallback_1 = (this.subscriptionObserverMap.get(subscriptionId) || {}).subscriptionFailedCallback;
                  if (typeof subscriptionFailedCallback_1 === "function") {
                    subscriptionFailedCallback_1();
                  }
                  return [
                    2
                    /*return*/
                  ];
                case 5:
                  _e = this.subscriptionObserverMap.get(subscriptionId), subscriptionFailedCallback = _e.subscriptionFailedCallback, subscriptionReadyCallback = _e.subscriptionReadyCallback;
                  this.subscriptionObserverMap.set(subscriptionId, {
                    observer,
                    subscriptionState,
                    variables,
                    query,
                    subscriptionReadyCallback,
                    subscriptionFailedCallback,
                    startAckTimeoutId: setTimeout(function() {
                      _this._timeoutStartSubscriptionAck.call(_this, subscriptionId);
                    }, START_ACK_TIMEOUT)
                  });
                  if (this.awsRealTimeSocket) {
                    this.awsRealTimeSocket.send(stringToAWSRealTime);
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._initializeWebSocketConnection = function(_a) {
          var _this = this;
          var appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, authenticationType = _a.authenticationType, apiKey = _a.apiKey, region = _a.region, credentials = _a.credentials, token = _a.token;
          if (this.socketStatus === types_1.SOCKET_STATUS.READY) {
            return;
          }
          return new Promise(function(res, rej) {
            return __awaiter(_this, void 0, void 0, function() {
              var payloadString, headerString, _a2, _b, headerQs, payloadQs, discoverableEndpoint, awsRealTimeUrl, err_2;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.promiseArray.push({ res, rej });
                    if (!(this.socketStatus === types_1.SOCKET_STATUS.CLOSED))
                      return [3, 5];
                    _c.label = 1;
                  case 1:
                    _c.trys.push([1, 4, , 5]);
                    this.socketStatus = types_1.SOCKET_STATUS.CONNECTING;
                    payloadString = "{}";
                    _b = (_a2 = JSON).stringify;
                    return [4, this._awsRealTimeHeaderBasedAuth({
                      authenticationType,
                      payload: payloadString,
                      canonicalUri: "/connect",
                      apiKey,
                      appSyncGraphqlEndpoint,
                      region,
                      credentials,
                      token,
                      graphql_headers: function() {
                      }
                    })];
                  case 2:
                    headerString = _b.apply(_a2, [_c.sent()]);
                    headerQs = Buffer.from(headerString).toString("base64");
                    payloadQs = Buffer.from(payloadString).toString("base64");
                    discoverableEndpoint = appSyncGraphqlEndpoint;
                    if (this.isCustomDomain(discoverableEndpoint)) {
                      discoverableEndpoint = discoverableEndpoint.concat(customDomainPath);
                    } else {
                      discoverableEndpoint = discoverableEndpoint.replace("appsync-api", "appsync-realtime-api").replace("gogi-beta", "grt-beta");
                    }
                    discoverableEndpoint = discoverableEndpoint.replace("https://", "wss://").replace("http://", "ws://");
                    awsRealTimeUrl = discoverableEndpoint + "?header=" + headerQs + "&payload=" + payloadQs;
                    return [4, this._initializeRetryableHandshake({ awsRealTimeUrl })];
                  case 3:
                    _c.sent();
                    this.promiseArray.forEach(function(_a3) {
                      var res2 = _a3.res;
                      logger("Notifying connection successful");
                      res2();
                    });
                    this.socketStatus = types_1.SOCKET_STATUS.READY;
                    this.promiseArray = [];
                    return [3, 5];
                  case 4:
                    err_2 = _c.sent();
                    this.promiseArray.forEach(function(_a3) {
                      var rej2 = _a3.rej;
                      return rej2(err_2);
                    });
                    this.promiseArray = [];
                    if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN) {
                      this.awsRealTimeSocket.close(3001);
                    }
                    this.awsRealTimeSocket = null;
                    this.socketStatus = types_1.SOCKET_STATUS.CLOSED;
                    return [3, 5];
                  case 5:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._awsRealTimeHeaderBasedAuth = function(_a) {
          var authenticationType = _a.authenticationType, payload = _a.payload, canonicalUri = _a.canonicalUri, appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, apiKey = _a.apiKey, region = _a.region, credentials = _a.credentials, token = _a.token, graphql_headers = _a.graphql_headers;
          return __awaiter(this, void 0, void 0, function() {
            var headerHandler, handler, host, result;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  headerHandler = {
                    API_KEY: this._awsRealTimeApiKeyHeader.bind(this),
                    AWS_IAM: this._awsRealTimeIAMHeader.bind(this),
                    OPENID_CONNECT: this._awsRealTimeAuthorizationHeader.bind(this),
                    AMAZON_COGNITO_USER_POOLS: this._awsRealTimeAuthorizationHeader.bind(this),
                    AWS_LAMBDA: this._awsRealTimeAuthorizationHeader.bind(this)
                  };
                  handler = headerHandler[authenticationType];
                  if (typeof handler !== "function") {
                    logger("Authentication type " + authenticationType + " not supported");
                    return [2, {}];
                  }
                  host = url.parse(appSyncGraphqlEndpoint).host;
                  return [4, handler({
                    payload,
                    canonicalUri,
                    appSyncGraphqlEndpoint,
                    apiKey,
                    region,
                    host,
                    credentials,
                    token,
                    graphql_headers
                  })];
                case 1:
                  result = _b.sent();
                  return [2, result];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._awsRealTimeAuthorizationHeader = function(_a) {
          var host = _a.host, token = _a.token, graphql_headers = _a.graphql_headers;
          return __awaiter(this, void 0, void 0, function() {
            var _b, _c, _d;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  _b = {};
                  if (!(typeof token === "function"))
                    return [3, 2];
                  return [4, token.call(void 0)];
                case 1:
                  _c = _e.sent();
                  return [3, 4];
                case 2:
                  return [4, token];
                case 3:
                  _c = _e.sent();
                  _e.label = 4;
                case 4:
                  _d = [(_b.Authorization = _c, _b.host = host, _b)];
                  return [4, graphql_headers()];
                case 5:
                  return [2, __assign.apply(void 0, _d.concat([_e.sent()]))];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._awsRealTimeApiKeyHeader = function(_a) {
          var apiKey = _a.apiKey, host = _a.host, graphql_headers = _a.graphql_headers;
          return __awaiter(this, void 0, void 0, function() {
            var dt, dtStr, _b;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  dt = new Date();
                  dtStr = dt.toISOString().replace(/[:\-]|\.\d{3}/g, "");
                  _b = [{ host, "x-amz-date": dtStr, "x-api-key": apiKey }];
                  return [4, graphql_headers()];
                case 1:
                  return [2, __assign.apply(void 0, _b.concat([_c.sent()]))];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._awsRealTimeIAMHeader = function(_a) {
          var payload = _a.payload, canonicalUri = _a.canonicalUri, appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, region = _a.region, credentials = _a.credentials;
          return __awaiter(this, void 0, void 0, function() {
            var endpointInfo, creds, _b, accessKeyId, secretAccessKey, sessionToken, formattedCredentials, request, signed_params;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  endpointInfo = {
                    region,
                    service: SERVICE
                  };
                  creds = typeof credentials === "function" ? credentials.call() : credentials || {};
                  if (!(creds && typeof creds.getPromise === "function"))
                    return [3, 2];
                  return [4, creds.getPromise()];
                case 1:
                  _c.sent();
                  _c.label = 2;
                case 2:
                  if (!creds) {
                    throw new Error("No credentials");
                  }
                  return [4, creds];
                case 3:
                  _b = _c.sent(), accessKeyId = _b.accessKeyId, secretAccessKey = _b.secretAccessKey, sessionToken = _b.sessionToken;
                  formattedCredentials = {
                    access_key: accessKeyId,
                    secret_key: secretAccessKey,
                    session_token: sessionToken
                  };
                  request = {
                    url: "" + appSyncGraphqlEndpoint + canonicalUri,
                    body: payload,
                    method: "POST",
                    headers: __assign({}, APPSYNC_REALTIME_HEADERS)
                  };
                  signed_params = aws_appsync_auth_link_1.Signer.sign(request, formattedCredentials, endpointInfo);
                  return [2, signed_params.headers];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._initializeRetryableHandshake = function(_a) {
          var awsRealTimeUrl = _a.awsRealTimeUrl;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  logger("Initializaling retryable Handshake");
                  return [4, retry_1.jitteredExponentialRetry(this._initializeHandshake.bind(this), [
                    { awsRealTimeUrl }
                  ])];
                case 1:
                  _b.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._initializeHandshake = function(_a) {
          var awsRealTimeUrl = _a.awsRealTimeUrl;
          return __awaiter(this, void 0, void 0, function() {
            var err_3, errorType, errorCode;
            var _this = this;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  logger("Initializing handshake " + awsRealTimeUrl);
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 4, , 5]);
                  return [4, function() {
                    return new Promise(function(res, rej) {
                      var newSocket = AppSyncRealTimeSubscriptionHandshakeLink2.createWebSocket(awsRealTimeUrl, "graphql-ws");
                      newSocket.onerror = function() {
                        logger("WebSocket connection error");
                      };
                      newSocket.onclose = function() {
                        rej(new Error("Connection handshake error"));
                      };
                      newSocket.onopen = function() {
                        _this.awsRealTimeSocket = newSocket;
                        return res();
                      };
                    });
                  }()];
                case 2:
                  _b.sent();
                  return [4, function() {
                    return new Promise(function(res, rej) {
                      var ackOk = false;
                      _this.awsRealTimeSocket.onerror = function(error) {
                        logger("WebSocket closed " + JSON.stringify(error));
                      };
                      _this.awsRealTimeSocket.onclose = function(event) {
                        logger("WebSocket closed " + event.reason);
                        rej(new Error(JSON.stringify(event)));
                      };
                      _this.awsRealTimeSocket.onmessage = function(message) {
                        var _a2;
                        logger("subscription message from AWS AppSyncRealTime: " + message.data + " ");
                        var data = JSON.parse(message.data);
                        var type = data.type, _b2 = data.payload, _c = (_b2 === void 0 ? {} : _b2).connectionTimeoutMs, connectionTimeoutMs = _c === void 0 ? DEFAULT_KEEP_ALIVE_TIMEOUT : _c;
                        if (type === types_1.MESSAGE_TYPES.GQL_CONNECTION_ACK) {
                          ackOk = true;
                          _this.keepAliveTimeout = (_a2 = _this.keepAliveTimeout) !== null && _a2 !== void 0 ? _a2 : connectionTimeoutMs;
                          _this.awsRealTimeSocket.onmessage = _this._handleIncomingSubscriptionMessage.bind(_this);
                          _this.awsRealTimeSocket.onerror = function(err) {
                            logger(err);
                            _this._errorDisconnect(types_1.CONTROL_MSG.CONNECTION_CLOSED);
                          };
                          _this.awsRealTimeSocket.onclose = function(event) {
                            logger("WebSocket closed " + event.reason);
                            _this._errorDisconnect(types_1.CONTROL_MSG.CONNECTION_CLOSED);
                          };
                          res("Cool, connected to AWS AppSyncRealTime");
                          return;
                        }
                        if (type === types_1.MESSAGE_TYPES.GQL_CONNECTION_ERROR) {
                          var _d = data.payload, _e = (_d === void 0 ? {} : _d).errors, _f = (_e === void 0 ? [] : _e)[0], _g = _f === void 0 ? {} : _f, _h = _g.errorType, errorType2 = _h === void 0 ? "" : _h, _j = _g.errorCode, errorCode2 = _j === void 0 ? 0 : _j;
                          rej({ errorType: errorType2, errorCode: errorCode2 });
                        }
                      };
                      var gqlInit = {
                        type: types_1.MESSAGE_TYPES.GQL_CONNECTION_INIT
                      };
                      _this.awsRealTimeSocket.send(JSON.stringify(gqlInit));
                      function checkAckOk() {
                        if (!ackOk) {
                          rej(new Error("Connection timeout: ack from AWSRealTime was not received on " + CONNECTION_INIT_TIMEOUT + " ms"));
                        }
                      }
                      setTimeout(checkAckOk.bind(_this), CONNECTION_INIT_TIMEOUT);
                    });
                  }()];
                case 3:
                  _b.sent();
                  return [3, 5];
                case 4:
                  err_3 = _b.sent();
                  errorType = err_3.errorType, errorCode = err_3.errorCode;
                  if (NON_RETRYABLE_CODES.indexOf(errorCode) >= 0) {
                    throw new retry_1.NonRetryableError(errorType);
                  } else if (errorType) {
                    throw new Error(errorType);
                  } else {
                    throw err_3;
                  }
                  return [3, 5];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._handleIncomingSubscriptionMessage = function(message) {
          logger("subscription message from AWS AppSync RealTime: " + message.data);
          var _a = JSON.parse(message.data), _b = _a.id, id = _b === void 0 ? "" : _b, payload = _a.payload, type = _a.type;
          var _c = this.subscriptionObserverMap.get(id) || {}, _d = _c.observer, observer = _d === void 0 ? null : _d, _e = _c.query, query = _e === void 0 ? "" : _e, _f = _c.variables, variables = _f === void 0 ? {} : _f, _g = _c.startAckTimeoutId, startAckTimeoutId = _g === void 0 ? 0 : _g, _h = _c.subscriptionReadyCallback, subscriptionReadyCallback = _h === void 0 ? null : _h, _j = _c.subscriptionFailedCallback, subscriptionFailedCallback = _j === void 0 ? null : _j;
          logger({ id, observer, query, variables });
          if (type === types_1.MESSAGE_TYPES.GQL_DATA && payload && payload.data) {
            if (observer) {
              observer.next(payload);
            } else {
              logger("observer not found for id: " + id);
            }
            return;
          }
          if (type === types_1.MESSAGE_TYPES.GQL_START_ACK) {
            logger("subscription ready for " + JSON.stringify({ query, variables }));
            if (typeof subscriptionReadyCallback === "function") {
              subscriptionReadyCallback();
            }
            clearTimeout(startAckTimeoutId);
            if (observer) {
              observer.next({
                data: payload,
                extensions: {
                  controlMsgType: "CONNECTED"
                }
              });
            } else {
              logger("observer not found for id: " + id);
            }
            var subscriptionState = types_1.SUBSCRIPTION_STATUS.CONNECTED;
            this.subscriptionObserverMap.set(id, {
              observer,
              query,
              variables,
              startAckTimeoutId: null,
              subscriptionState,
              subscriptionReadyCallback,
              subscriptionFailedCallback
            });
            return;
          }
          if (type === types_1.MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {
            clearTimeout(this.keepAliveTimeoutId);
            this.keepAliveTimeoutId = setTimeout(this._errorDisconnect.bind(this, types_1.CONTROL_MSG.TIMEOUT_DISCONNECT), this.keepAliveTimeout);
            return;
          }
          if (type === types_1.MESSAGE_TYPES.GQL_ERROR) {
            var subscriptionState = types_1.SUBSCRIPTION_STATUS.FAILED;
            this.subscriptionObserverMap.set(id, {
              observer,
              query,
              variables,
              startAckTimeoutId,
              subscriptionReadyCallback,
              subscriptionFailedCallback,
              subscriptionState
            });
            observer.error({
              errors: [
                __assign({}, new graphql_1.GraphQLError("Connection failed: " + JSON.stringify(payload)))
              ]
            });
            clearTimeout(startAckTimeoutId);
            observer.complete();
            if (typeof subscriptionFailedCallback === "function") {
              subscriptionFailedCallback();
            }
          }
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._errorDisconnect = function(msg) {
          logger("Disconnect error: " + msg);
          this.subscriptionObserverMap.forEach(function(_a) {
            var observer = _a.observer;
            if (observer && !observer.closed) {
              observer.error({
                errors: [__assign({}, new graphql_1.GraphQLError(msg))]
              });
            }
          });
          this.subscriptionObserverMap.clear();
          if (this.awsRealTimeSocket) {
            this.awsRealTimeSocket.close();
          }
          this.socketStatus = types_1.SOCKET_STATUS.CLOSED;
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.prototype._timeoutStartSubscriptionAck = function(subscriptionId) {
          var _a = this.subscriptionObserverMap.get(subscriptionId) || {}, observer = _a.observer, query = _a.query, variables = _a.variables;
          if (!observer) {
            return;
          }
          this.subscriptionObserverMap.set(subscriptionId, {
            observer,
            query,
            variables,
            subscriptionState: types_1.SUBSCRIPTION_STATUS.FAILED
          });
          if (observer && !observer.closed) {
            observer.error({
              errors: [
                __assign({}, new graphql_1.GraphQLError("Subscription timeout " + JSON.stringify({ query, variables })))
              ]
            });
            observer.complete();
          }
          logger("timeoutStartSubscription", JSON.stringify({ query, variables }));
        };
        AppSyncRealTimeSubscriptionHandshakeLink2.createWebSocket = function(awsRealTimeUrl, protocol) {
          return new WebSocket(awsRealTimeUrl, protocol);
        };
        return AppSyncRealTimeSubscriptionHandshakeLink2;
      }(core_1.ApolloLink)
    );
    exports.AppSyncRealTimeSubscriptionHandshakeLink = AppSyncRealTimeSubscriptionHandshakeLink;
  }
});

// ../../node_modules/aws-appsync-subscription-link/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/aws-appsync-subscription-link/lib/index.js"(exports) {
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscription_handshake_link_1 = require_subscription_handshake_link();
    exports.CONTROL_EVENTS_KEY = subscription_handshake_link_1.CONTROL_EVENTS_KEY;
    var core_1 = (init_core2(), __toCommonJS(core_exports));
    var http_1 = (init_http(), __toCommonJS(http_exports));
    var utilities_1 = (init_utilities(), __toCommonJS(utilities_exports));
    var non_terminating_link_1 = require_non_terminating_link();
    var realtime_subscription_handshake_link_1 = require_realtime_subscription_handshake_link();
    function createSubscriptionHandshakeLink(infoOrUrl, theResultsFetcherLink) {
      var resultsFetcherLink, subscriptionLinks;
      if (typeof infoOrUrl === "string") {
        resultsFetcherLink = theResultsFetcherLink || http_1.createHttpLink({ uri: infoOrUrl });
        subscriptionLinks = core_1.ApolloLink.from([
          new non_terminating_link_1.NonTerminatingLink("controlMessages", {
            link: new core_1.ApolloLink(function(operation, _forward) {
              return new core_1.Observable(function(observer) {
                var _a;
                var _b = operation, _c = _b.variables, _d = subscription_handshake_link_1.CONTROL_EVENTS_KEY, controlEvents = _c[_d], variables = __rest2(_c, [typeof _d === "symbol" ? _d : _d + ""]);
                if (typeof controlEvents !== "undefined") {
                  operation.variables = variables;
                }
                observer.next((_a = {}, _a[subscription_handshake_link_1.CONTROL_EVENTS_KEY] = controlEvents, _a));
                return function() {
                };
              });
            })
          }),
          new non_terminating_link_1.NonTerminatingLink("subsInfo", { link: resultsFetcherLink }),
          new subscription_handshake_link_1.SubscriptionHandshakeLink("subsInfo")
        ]);
      } else {
        var url = infoOrUrl.url;
        resultsFetcherLink = theResultsFetcherLink || http_1.createHttpLink({ uri: url });
        subscriptionLinks = new realtime_subscription_handshake_link_1.AppSyncRealTimeSubscriptionHandshakeLink(infoOrUrl);
      }
      return core_1.ApolloLink.split(function(operation) {
        var query = operation.query;
        var _a = utilities_1.getMainDefinition(query), kind = _a.kind, graphqlOperation = _a.operation;
        var isSubscription = kind === "OperationDefinition" && graphqlOperation === "subscription";
        return isSubscription;
      }, subscriptionLinks, resultsFetcherLink);
    }
    exports.createSubscriptionHandshakeLink = createSubscriptionHandshakeLink;
  }
});
export default require_lib2();
/*! Bundled license information:

aws-appsync-subscription-link/lib/utils/index.js:
  (*!
   * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   * SPDX-License-Identifier: Apache-2.0
   *)

aws-appsync-subscription-link/lib/subscription-handshake-link.js:
  (*!
   * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   * SPDX-License-Identifier: Apache-2.0
   *)

aws-appsync-subscription-link/lib/non-terminating-link.js:
  (*!
   * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   * SPDX-License-Identifier: Apache-2.0
   *)

aws-appsync-subscription-link/lib/realtime-subscription-handshake-link.js:
  (*!
   * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=aws-appsync-subscription-link.js.map
